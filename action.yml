name: 'Build Neon Library'
description: 'Build a Neon library.'
inputs:
  working-directory:
    description: 'Working directory to run commands from, relative to repo root.'
    required: false
    default: '.'
  output-directory:
    description: 'Directory to produce the build, relative to working-directory.'
    required: false
    default: 'dist'
  platform:
    description: 'Node platform to build for (e.g. darwin-arm64 or linux-x64-gnu).'
    required: true
  platforms-directory:
    description: 'Directory containing pre-existing binary package structure, relative to working-directory.'
    required: false
    default: 'platforms'
  node-version:
    description: 'Node version to install.'
    required: false
    default: ''
  rust-version:
    description: 'Rust version to install.'
    required: false
    default: 'stable'
  registry-url:
    description: 'npm registry URL.'
    required: false
    default: ''
  github-release:
    description: 'Publish the tarball to a GitHub Release.'
    required: false
    default: false
  npm-publish:
    description: 'Publish the tarball to npm.'
    required: false
    default: false
  use-cross:
    description: 'Use cross-rs to run the build instead of cargo.'
    required: false
    default: false
  validate:
    description: 'Validate tarball contents after building.'
    required: false
    default: true
branding:
  icon: 'cpu'
  color: 'blue'
runs:
  using: "composite"
  steps:
    - name: Compute Variables
      id: vars
      shell: bash
      run: |
        use_cross=${{ inputs['use-cross'] }}
        if [[ "$use_cross" = true ]]; then
          echo script=cross > $GITHUB_OUTPUT
        else
          echo script=build > $GITHUB_OUTPUT
        fi
        echo target=$(npx @neon-rs/cli list-platforms | jq -r '.["${{ inputs.platform }}"]') >> $GITHUB_OUTPUT
      working-directory: ${{ inputs['working-directory' ]}}
    - name: Install Node
      uses: actions/setup-node@v3
      with:
        node-version: ${{ inputs['node-version'] }}
        registry-url: ${{ inputs['registry-url'] }}
        cache: npm
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ inputs['rust-version'] }}
        target: ${{ steps.vars.outputs.target }}
        override: true
    - name: Install cross-rs
      if: ${{ inputs['use-cross'] == 'true' }}
      uses: baptiste0928/cargo-install@v2
      with:
        crate: cross
    - name: Install Dependencies
      shell: bash
      run: npm install
      working-directory: ${{ inputs['working-directory'] }}
    - name: Build
      shell: bash
      env:
        CARGO_BUILD_TARGET: ${{ steps.vars.outputs.target }}
      run: npm run ${{ steps.vars.outputs.script }}
      working-directory: ${{ inputs['working-directory'] }}
    - name: Pack
      id: pack
      shell: bash
      run: |
        mv index.node "${{ inputs['platforms-directory'] }}/${{ inputs['platform'] }}/index.node"
        platform_dir=${{ inputs['platforms-directory'] }}/${{ inputs['platform'] }}
        # NOTE: The `xargs basename` component is a workaround for https://github.com/npm/cli/issues/3405
        filename=$( (cd $platform_dir && npm pack --json | jq '.[0].filename' | xargs basename) )
        # Ensure the output directory exists.
        mkdir -p ${{ inputs['output-directory'] }}
        # Copy instead of move since Windows runners host temp directories
        # on a different device (which causes mv to fail).
        cp $platform_dir/$filename ${{ inputs['output-directory'] }}
        # Diagnostics
        tar tvzf ${{ inputs['output-directory'] }}/$filename
        echo "filename=$filename" > $GITHUB_OUTPUT
      working-directory: ${{ inputs['working-directory'] }}
    - name: Validate
      if: ${{ inputs['validate'] == 'true' }}
      shell: bash
      run: |
        expected_arch=$(node -e 'console.log("${{ inputs['platform'] }}".split("-")[1])')
        platform_dir=${{ inputs['platforms-directory'] }}/${{ inputs['platform'] }}
        entry=$(cat $platform_dir/package.json | jq -r .main)
        echo "entry=$entry"
        entry_file=$(basename $entry)
        echo "entry_file=$entry_file"
        entry_dir=$(dirname $entry)
        echo "entry_dir=$entry_dir"
        os_config="${{ github.action_path }}/data/${{ runner.os }}.json"
        echo "os_config=$os_config"
        cmd=$(cat $os_config | jq -r .cmd)
        echo "cmd=$cmd"
        parse=$(cat $os_config | jq -r .parse)
        echo "parse=$parse"
        filename=${{ steps.pack.outputs.filename }}
        echo "***** Validating: $filename *****"
        without_ext=${filename%.*}
        mkdir -p ${{ runner.temp }}/$without_ext
        cp ${{ inputs['output-directory'] }}/$filename ${{ runner.temp }}/$without_ext
        pushd ${{ runner.temp }}/$without_ext
        tar xvzf ./$filename
        cd package
        cd $entry_dir
        arch=$(eval "$cmd $entry_file | $parse")
        echo "arch=$arch"
        actual_arch=$(cat $os_config | jq -r ".arch | .[\"$arch\"]")
        popd
        echo "expected_arch=$expected_arch"
        echo "actual_arch=$actual_arch"
        if [ $expected_arch != $actual_arch ]; then
          echo "$filename packed for ${{ inputs['platform'] }}, found $actual_arch"
          exit 1
        fi
      working-directory: ${{ inputs['working-directory'] }}
    - name: Release
      if: ${{ inputs['github-release'] == 'true' }}
      uses: softprops/action-gh-release@v1
      with:
        files: ${{ inputs['working-directory'] }}/${{ inputs['output-directory'] }}/${{ steps.pack.outputs.filename }}
    - name: Publish
      if: ${{ inputs['npm-publish'] == 'true' }}
      shell: bash
      run: npm publish ${{ steps.pack.outputs.filename }}
      working-directory: ${{ inputs['working-directory'] }}/${{ inputs['output-directory'] }}
